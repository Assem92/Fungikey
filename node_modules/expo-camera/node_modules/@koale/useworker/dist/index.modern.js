import e from"react";import r from"dequal";const t=e=>r=>{const[t]=r.data;return Promise.resolve(e.fn(...t)).then(r=>{const t="auto"===e.transferable&&(n=r,"ArrayBuffer"in self&&n instanceof ArrayBuffer||"MessagePort"in self&&n instanceof MessagePort||"ImageBitmap"in self&&n instanceof ImageBitmap||"OffscreenCanvas"in self&&n instanceof OffscreenCanvas)?[r]:[];var n;postMessage(["SUCCESS",r],t)}).catch(e=>{postMessage(["ERROR",e])})},n=(e,r,n)=>{const a=`\n    ${(e=>0===e.length?"":`importScripts(${e.map(e=>`'${e}'`).toString()})`)(r)};\n    onmessage=(${t})({\n      fn: (${e}),\n      transferable: '${n}'\n    })\n  `,o=new Blob([a],{type:"text/javascript"});return URL.createObjectURL(o)};var a;!function(e){e.PENDING="PENDING",e.SUCCESS="SUCCESS",e.RUNNING="RUNNING",e.ERROR="ERROR",e.TIMEOUT_EXPIRED="TIMEOUT_EXPIRED"}(a||(a={}));var o,s=a;!function(e){e.AUTO="auto",e.NONE="none"}(o||(o={}));const u={timeout:void 0,remoteDependencies:[],autoTerminate:!0,transferable:o.AUTO},c=(t,a=u)=>{const[c,i]=e.useState(s.PENDING),l=e.useRef(),f=e.useRef(!1),m=e.useRef({}),R=e.useRef(),E=e.useCallback(e=>{f.current=e===s.RUNNING,i(e)},[]),v=e.useCallback(()=>{var e;null!==(e=l.current)&&void 0!==e&&e._url&&(l.current.terminate(),URL.revokeObjectURL(l.current._url),m.current={},l.current=void 0,window.clearTimeout(R.current))},[]),d=e.useCallback(e=>{(null!=a.autoTerminate?a.autoTerminate:u.autoTerminate)&&v(),E(e)},[a.autoTerminate,v,E]),p=((o,c)=>{const i=e.useRef(c);return r(i.current,c)||(i.current=c),e.useCallback(()=>{const{remoteDependencies:e=u.remoteDependencies,timeout:r=u.timeout,transferable:o=u.transferable}=a,c=n(t,e,o),i=new Worker(c);return i._url=c,i.onmessage=e=>{var r,t,n,a;const[o,u]=e.data;switch(o){case s.SUCCESS:null===(r=(t=m.current).resolve)||void 0===r||r.call(t,u),d(s.SUCCESS);break;default:null===(n=(a=m.current).reject)||void 0===n||n.call(a,u),d(s.ERROR)}},i.onerror=e=>{var r,t;null===(r=(t=m.current).reject)||void 0===r||r.call(t,e),d(s.ERROR)},r&&(R.current=window.setTimeout(()=>{v(),E(s.TIMEOUT_EXPIRED)},r)),i},i.current)})(0,[t,a,v]),w=e.useCallback((...e)=>{const{transferable:r=u.transferable}=a;return new Promise((t,n)=>{var a;m.current={resolve:t,reject:n};const u=r===o.AUTO?e.filter(e=>"ArrayBuffer"in window&&e instanceof ArrayBuffer||"MessagePort"in window&&e instanceof MessagePort||"ImageBitmap"in window&&e instanceof ImageBitmap||"OffscreenCanvas"in window&&e instanceof OffscreenCanvas):[];null===(a=l.current)||void 0===a||a.postMessage([[...e]],u),E(s.RUNNING)})},[E]),C=e.useCallback((...e)=>{const r=null!=a.autoTerminate?a.autoTerminate:u.autoTerminate;return f.current?(console.error("[useWorker] You can only run one instance of the worker at a time, if you want to run more than one in parallel, create another instance with the hook useWorker(). Read more: https://github.com/alewin/useWorker"),Promise.reject()):(!r&&l.current||(l.current=p()),w(...e))},[a.autoTerminate,p,w]),N={status:c,kill:v};return e.useEffect(()=>()=>{v()},[v]),[C,N]};export{a as WORKER_STATUS,c as useWorker};
//# sourceMappingURL=index.modern.js.map
